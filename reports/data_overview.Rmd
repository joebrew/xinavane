---
title: "Xinavane data overview"
author: 
  - Laia Cirera
  - Joe Brew
  - Elisa Sicuri  
date: "March 8, 2016"
output:
  pdf_document:
    includes:
      in_header: mystyle.sty
tables: yes
latex_engine: xelatex
highlight: zenburn
toc: yes
fig_width: 4
fig_height: 2.6
header-includes:
     - \usepackage{longtable}
---


```{r, echo = FALSE, warning = FALSE, message = FALSE, comment = NA, error= FALSE }
# No scientific notation
options(scipen=999)

##### PACKAGES
library(knitr)
library(png)
library(grid)
library(extrafont)
library(gridExtra)
library(ggmap)
library(raster)
library(tidyr)
library(RColorBrewer)
loadfonts(device = 'postscript', quiet = TRUE)

# BASIC KNITR OPTIONS
opts_chunk$set(comment = NA, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 3.5)
options(xtable.comment = FALSE)
```

```{r, echo = FALSE, warning = FALSE, message = FALSE, comment = NA, error= FALSE }
##### READ IN DATA
setwd('..')
source('code/read_in.R')
setwd('reports')
```
\newpage


# Exploration

## Absences  


Absenteeism data spans from `r format(min(ab$date, na.rm = TRUE), '%B %d, %Y')` until `r format(max(ab$date, na.rm = TRUE), '%B %d, %Y')`. On average, there are `r ab %>% group_by(date) %>% tally %>% summarise(mean(n)) %>% as.numeric() %>% round` absences per day.  Though there appears to be some longer-term variation in the below chart, it's clear that the most important factor is weekly seasonality:  

```{r}
temp <- ab %>%
  group_by(date) %>%
  tally
ggplot(data = temp, 
       aes(x = date, y = n)) +
  geom_line(alpha = 0.6) +
  geom_point(alpha = 0.6) +
  geom_smooth() +
  xlab('Date') +
  ylab('Absences') +
  ggtitle('Crude worker absences')
```

## Adjustment for worker days  

Crude absence data is relatively useless, given that it doesn't take into account the number of workers "susceptible" of absence on any given day (ie, the number of workers who were _supposed_ to work).  This explains why there are much fewer absences at certain times (Sunday) relative to others.

```{r}
temp <- ab %>%
  mutate(dow = weekdays(date)) %>%
  group_by(dow) %>%
  tally %>%
  filter(!is.na(dow))
temp <- temp[c(2,6,7,5,1,3,4),]
temp$dow <- factor(temp$dow, levels = temp$dow)

ggplot(data = temp,
       aes(x = dow,
           y = n)) +
  geom_bar(stat = 'identity', alpha = 0.6, fill = 'darkblue') +
  xlab('Day of week') +
  ylab('Cumulative absences') +
  ggtitle('Crude absences by day of week') 
```

To account for the above issues, we can instead calculate an _absenteeism rate_, taking into account the employment beginning and end dates, leave statuses and working schedule of all the workers in the `Xinavane_plantilla trabajadores_agriculture_joe.xls` dataset. Essentially, we calculate the number of eligible workers for each day (the denominator in our rate). The result looks like this:

```{r}

# Create a dataframe of eligible absences
x <- expand.grid(
  date = seq(min(ab$date, na.rm = TRUE),
             max(ab$date, na.rm = TRUE),
             by = 1),
  number = unique(workers$number))
# Get day of week
x$dow <- weekdays(x$date)

# Remove those dates for which the worker has off
x <- left_join(x = x,
               y = workers %>%
                 dplyr::select(number, days_off),
               by = c("number")) %>%
  filter(dow != days_off)

# Get start and  dates
x <- left_join(x = x,
               y = workers %>%
                 dplyr::select(number,
                               company_entry_date))

# Remove those workers who hadn't yet started
x <- x %>%
  dplyr::filter(date >= company_entry_date)

# x is now a dataframe containg all
# unique worker-days for which a worker
# SHOULD have worked

# Now we need to bring absences into x
x <- x %>%
  left_join(ab %>%
              mutate(absence = TRUE) %>%
              dplyr::select(number, type, date, absence)) %>%
  mutate(absence = ifelse(is.na(absence), FALSE, absence))

# Join worker data to our absence/eligibility dataframe
df <- x %>%
  left_join(workers %>%
              dplyr::select(-days_off, -company_entry_date, -type))

# Write spreadsheets for laia (requested on 2016-04-13)
if(!dir.exists('~/Desktop/magude')){
  dir.create('~/Desktop/magude')
}
dd <- getwd()
setwd('~/Desktop/magude')
laia <- df
write_csv(df, 'xinavane_worker_absences_and_presences.csv')
setwd(dd)

rm(x, dd)
# # ALTERNATIVE, LESS USEFUL APPROACH
# # (for compatibility only)
# # Create a dataframe of every day
# df <- data.frame(
#   date = seq(min(ab$date, na.rm = TRUE),
#              max(ab$date, na.rm = TRUE),
#              by = 1))
# # Get day of week
# df$dow <- weekdays(df$date)
# 
# # Loop through each date, getting eligible workers
# df$eligibles <- NA
# for (i in 1:nrow(df)){
#   df$eligibles[i] <- 
#     nrow(workers[workers$company_entry_date <= df$date[i] &
#                    workers$days_off != df$dow[i],])
# }
# 

temp <- df %>%
  group_by(date) %>%
  summarise(n = n(),
            absences = length(which(absence))) %>%
  mutate( p = absences / n * 100)
temp_g <- gather(temp, key, value, n:absences)
temp_g$key <-
  ifelse(temp_g$key == 'absences', 'Worker absence',
         ifelse(temp_g$key == 'n', 'Eligible worker-day',
                NA))
temp_g$key <-
  factor(temp_g$key, levels = rev(unique(temp_g$key)))

# ggplot(data = temp_g,
#        aes(x = date, y = value, group = key, fill = key)) +
#   geom_area() +
#   xlab('Date') +
#   ylab('Number of eligible workers') +
#   ggtitle('Worker scheduling')

ggplot(data = temp) +
  geom_area(aes(x = date, y = n), fill = 'darkblue', alpha = 0.7) +
  geom_area(aes(x = date, y = absences), fill = 'darkorange', alpha = 0.6) +
  xlab('Date') +
  ylab('Worker-days') +
  ggtitle('Absences (orange) and worker-days observed (blue)')
```

Absenteeism b

## Absenteeism rate  

The absenteeism rate is calculated by dividing the number of worker-absences per day over the number of worker-days on the schedule (ie, those who were _supposed_ to work that day).  Over time, absenteeism at Xinavane appears like this.



```{r}
ggplot(data = temp,
       aes(x = date, y = p)) +
  geom_area(alpha = 0.6, fill = 'darkorange') +
  xlab('Date') +
  ylab('Absenteeism rate (%)') +
  ggtitle('Absenteeism rate during study period') +
  geom_smooth() 
```

The daily average absenteeism rate (adjusted for worker eligibility) is `r round(weighted.mean(temp$p, temp$n), digits = 2)`%.  

## Absenteeism rate by worker type  

Agricultural workers have significantly higher absenteeism than those that work in the factory or in general services.  

```{r}
temp <- df %>%
  group_by(date, worker_type) %>%
  summarise(n = n(),
            absences = length(which(absence))) %>%
  mutate( p = absences / n * 100)

cols <- brewer.pal(n = length(unique(temp$worker_type)), 'Spectral')

ggplot(data = temp,
       aes(x = date, y = p, group = worker_type, color = worker_type)) +
  geom_line(alpha = 0.3) +
  geom_point(alpha = 0.3) +
  geom_smooth(alpha = 0.1) +
  xlab('Date') +
  ylab('Absenteeism rate') +
  scale_color_manual(values = cols,
                     name = 'Worker type') +
  ggtitle('Worker absenteeism by type')

```

## Geography  

```{r}
# Create better address string
temp <- workers
temp$location_string <- paste0(ifelse(is.na(temp$address_4),
                                      '',
                                      paste0(temp$address_4, ', ')),
                               temp$address_3,
                               ', Mozambique')
moz <- getData(name = 'GADM', country = 'MOZ', level = 3)
moz_gg <- get_map(apply(coordinates(moz), 2, mean),
                  zoom = 6,
                  maptype = 'terrain')
ggmap(moz_gg) +
  xlab('Longitude') +
  ylab('Latitude')
```

Unfortunately, the geographic data in the workers dataset is of inconsistent and low quality.  The `home location` field contains many missing and proprietary names, and even when addresses are provided, modern geocoding API's are largely unable to match at a level more granular than the city/town.  

However, given the relatively small size of the number of workers (6,185), and the fact that a majority are on-site or nearby, manual geocoding of each location would be feasible (using typical hand-held cellular devices).

## Age  

To the extent that absenteeism is confounded with health (which is in turn affected by age), it's important to note the age of workers.

```{r}
temp <- workers
temp$age <- as.numeric((Sys.Date() - temp$date_of_birth) / 365.25)
ggplot(data = temp,
       aes(x = age)) +
  geom_density(fill = 'darkblue', alpha = 0.6) +
  xlab('Age (years)') +
  ylab('Density') +
  ggtitle('Age distribution of Xinavane workers')
```

It's worthwhile to note that the age of workers varies significantly by _type_:

```{r}
temp <- temp[!is.na(temp$type),]
ggplot(data = temp,
       aes(x = type, 
           y = age)) +
  geom_jitter(alpha = 0.2) +
  geom_violin(alpha = 0.4, fill = 'darkorange') +
  xlab('Worker type') +
  ylab('Age of workers (years)') +
  ggtitle('Distribution of worker age by type')
```

Worker age also varies significantly by category:  

```{r}
temp <- temp[!is.na(temp$category),]
ggplot(data = temp,
       aes(x = category, 
           y = age)) +
  geom_jitter(alpha = 0.2) +
  geom_violin(alpha = 0.4, fill = 'darkorange') +
  xlab('Worker category') +
  ylab('Age of workers (years)') +
  ggtitle('Distribution of worker age by category')
```

Age does not appear to be correlated with absences:

```{r}
temp <- df %>%
  mutate(age = as.numeric((Sys.Date() - date_of_birth) / 365.25)) %>%
  group_by(number) %>%
  summarise(absenteeism_rate = length(which(absence)) / n() * 100,
            age = first(age)) %>%
  filter(age <= 70)

ggplot(data = temp,
       aes(x = age, y = absenteeism_rate)) +
  geom_point(alpha = 0.2) +
  xlab('Age') +
  ylab('Absenteeism rate') +
  geom_smooth() +
  ggtitle('Age and absenteeism')
```

When we group by decade, a trend becomes slightly more apparent:

```{r}
temp$age_group <- factor(floor(temp$age / 10) * 10)

ggplot(data = temp,
       aes(x = age_group, 
           y = absenteeism_rate)) +
  geom_jitter(alpha = 0.2) +
  geom_violin(alpha = 0.4, fill = 'darkorange') +
  xlab('Age group (by decade)') +
  ylab('Absenteeism rate') +
  ggtitle('Absenteeism rate by age (grouped)')


```

## Gender  

The ratio of males to females at Xinavane is greater than 2 to 1:

```{r}
ggplot(data = workers[!is.na(workers$gender),], aes(gender)) +
  geom_bar(fill = 'darkblue', alpha = 0.6) +
  xlab('Gender') +
  ylab('Workers') +
  ggtitle('Distribution of worker gender')
```



```{r}
temp <- df %>% 
  filter(!is.na(gender)) %>%
  group_by(gender) %>%
    summarise(n = n(),
            absences = length(which(absence))) %>%
  mutate( p = absences / n * 100)

ggplot(data = temp,
       aes(x = gender, y = p)) +
  geom_bar(stat = 'identity',
           color = 'black',
           fill = 'darkorange',
           alpha = 0.6) +
  xlab('Gender') +
  ylab('Absenteeism rate') +
  ggtitle('Absenteeism rate by gender') +
  geom_label(aes(label = paste0(round(p, digits = 2), '%')))
```

If we examine absences over time by gender, it is difficult to distinguish a trend:

```{r}
temp <- df %>%
  group_by(date, gender) %>%
      summarise(n = n(),
            absences = length(which(absence))) %>%
  mutate( p = absences / n * 100)

cols <- c('blue', 'red')
ggplot(data = temp,
       aes(x = date, y = p, group = gender, color = gender)) +
  geom_line(alpha = 0.3) +
  geom_point(alpha = 0.3) +
  geom_smooth(alpha = 0.1) +
  xlab('Date') +
  ylab('Absenteeism rate') +
  scale_color_manual(values = cols,
                     name = 'Gender') +
  ggtitle('Worker absenteeism by gender')

```

## Marital status  

Either (a) the facility has a highly unusual subset of single Mozambicans or (b) marriage is underreported in the data:  

```{r}
ggplot(data = workers[!is.na(workers$marital_status),], aes(marital_status)) +
  geom_bar(fill = 'darkblue', alpha = 0.6) +
  xlab('Marital status') +
  ylab('Workers') +
  ggtitle('Distribution of worker marital status')
```


# Details  

All code for the cleaning, analysis and generation of this report are hosted on [github](https://github.com/joebrew/xinavane).

******

```{r, fig.height = 2.5}
barplot(1, border = NA, col = 'white', yaxt = 'n')
```

![alt text](../img/is_global.jpg)

